<color=#dc0073>import</color> random
<color=#dc0073>from</color> Individual <color=#dc0073>import</color> Individual

<color=#f5b700>class</color> <color=#dc0073>SelectorRoulette</color>:
    
    <color=#ffa704>@staticmethod</color>
    <color=#f5b700>def</color> <color=#7b3fca>get_distributed_weight</color>(generation: <color=#dc0073>list</color>[Individual]) -> <color=#dc0073>list</color>:
        max_score = <color=#dc0073>max</color>(generation, key = <color=#f5b700>lambda</color> x: x.score)
        reversed_eval = <color=#dc0073>map</color>(<color=#f5b700>lambda</color> x: max_score - x.score + <color=#ffffff>1</color>, generation) 
        sum_eval = <color=#dc0073>sum</color>(reversed_eval)
        eval_percentage = <color=#dc0073>map</color>(<color=#f5b700>lambda</color> x: x/sum_eval, reversed_eval)

        <color=#f5b700>for</color> i in <color=#dc0073>range</color>(<color=#dc0073>len</color>(eval_percentage) - <color=#ffffff>1</color>):
            eval_percentage[i+<color=#ffffff>1</color>] += eval_percentage[i]

        <color=#f5b700>return</color> eval_percentage

    <color=#ffa704>@staticmethod</color>
    <color=#f5b700>def</color> <color=#7b3fca>get_index_for_value</color>(distributed_weights, value):
        <color=#f5b700>for</color> i in <color=#dc0073>range</color>(<color=#dc0073>len</color>(distributed_weights)):
            <color=#f5b700>if</color> value <= distributed_weights[i]:
                <color=#f5b700>return</color> i

    <color=#f5b700>def</color> <color=#7b3fca>get</color>(<color=#01befe>self</color>, generation):
        rand_float = random.random()
        distributed_weights = <color=#01befe>self</color>.get_distributed_weight(generation)
        index = <color=#01befe>self</color>.get_index_for_value(distributed_weights, rand_float)
        <color=#f5b700>return</color> generation[index]
